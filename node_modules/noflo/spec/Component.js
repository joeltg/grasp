var chai, component, socket;

if (typeof process !== 'undefined' && process.execPath && process.execPath.match(/node|iojs/)) {
  if (!chai) {
    chai = require('chai');
  }
  component = require('../src/lib/Component.coffee');
  socket = require('../src/lib/InternalSocket.coffee');
} else {
  component = require('noflo/src/lib/Component.js');
  socket = require('noflo/src/lib/InternalSocket.js');
}

describe('Component', function() {
  describe('with required ports', function() {
    it('should throw an error upon sending packet to an unattached required port', function() {
      var c, s2;
      s2 = new socket.InternalSocket;
      c = new component.Component({
        outPorts: {
          required_port: {
            required: true
          },
          optional_port: {}
        }
      });
      c.outPorts.optional_port.attach(s2);
      return chai.expect(function() {
        return c.outPorts.required_port.send('foo');
      }).to["throw"]();
    });
    return it('should be cool with an attached port', function() {
      var c, f, s1, s2;
      s1 = new socket.InternalSocket;
      s2 = new socket.InternalSocket;
      c = new component.Component({
        inPorts: {
          required_port: {
            required: true
          },
          optional_port: {}
        }
      });
      c.inPorts.required_port.attach(s1);
      c.inPorts.optional_port.attach(s2);
      f = function() {
        s1.send('some-more-data');
        return s2.send('some-data');
      };
      return chai.expect(f).to.not["throw"]();
    });
  });
  describe('with component creation shorthand', function() {
    it('should make component creation easy', function(done) {
      var c, s1, s2;
      c = new component.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              return chai.expect(component).to.equal(c);
            }
          },
          just_processor: function(event, packet, component) {
            if (event !== 'data') {
              return;
            }
            chai.expect(packet).to.equal('some-data');
            chai.expect(component).to.equal(c);
            return done();
          }
        }
      });
      s1 = new socket.InternalSocket;
      c.inPorts["in"].attach(s1);
      c.inPorts["in"].nodeInstance = c;
      s2 = new socket.InternalSocket;
      c.inPorts.just_processor.attach(s1);
      c.inPorts.just_processor.nodeInstance = c;
      s1.send('some-data');
      return s2.send('some-data');
    });
    it('should throw errors if there is no error port', function(done) {
      var c, s1;
      c = new component.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              chai.expect(component).to.equal(c);
              chai.expect(function() {
                return c.error(new Error);
              }).to["throw"](Error);
              return done();
            }
          }
        }
      });
      s1 = new socket.InternalSocket;
      c.inPorts["in"].attach(s1);
      c.inPorts["in"].nodeInstance = c;
      return s1.send('some-data');
    });
    it('should throw errors if there is a non-attached error port', function(done) {
      var c, s1;
      c = new component.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              chai.expect(component).to.equal(c);
              chai.expect(function() {
                return c.error(new Error);
              }).to["throw"](Error);
              return done();
            }
          }
        },
        outPorts: {
          error: {
            datatype: 'object',
            required: true
          }
        }
      });
      s1 = new socket.InternalSocket;
      c.inPorts["in"].attach(s1);
      c.inPorts["in"].nodeInstance = c;
      return s1.send('some-data');
    });
    it('should not throw errors if there is a non-required error port', function(done) {
      var c, s1;
      c = new component.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              chai.expect(component).to.equal(c);
              c.error(new Error);
              return done();
            }
          }
        },
        outPorts: {
          error: {
            required: false
          }
        }
      });
      s1 = new socket.InternalSocket;
      c.inPorts["in"].attach(s1);
      c.inPorts["in"].nodeInstance = c;
      return s1.send('some-data');
    });
    return it('should send errors if there is a connected error port', function(done) {
      var c, groups, grps, s1, s2;
      grps = [];
      c = new component.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event === 'begingroup') {
                grps.push(packet);
              }
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              chai.expect(component).to.equal(c);
              return c.error(new Error, grps);
            }
          }
        },
        outPorts: {
          error: {
            datatype: 'object'
          }
        }
      });
      s1 = new socket.InternalSocket;
      s2 = new socket.InternalSocket;
      groups = ['foo', 'bar'];
      s2.on('begingroup', function(grp) {
        return chai.expect(grp).to.equal(groups.shift());
      });
      s2.on('data', function(err) {
        chai.expect(err).to.be.an.instanceOf(Error);
        chai.expect(groups.length).to.equal(0);
        return done();
      });
      c.inPorts["in"].attach(s1);
      c.outPorts.error.attach(s2);
      c.inPorts["in"].nodeInstance = c;
      s1.beginGroup('foo');
      s1.beginGroup('bar');
      return s1.send('some-data');
    });
  });
  describe('defining ports with invalid names', function() {
    it('should throw an error with uppercase letters in inport', function() {
      var shorthand;
      shorthand = function() {
        var c;
        return c = new component.Component({
          inPorts: {
            fooPort: {}
          }
        });
      };
      return chai.expect(shorthand).to["throw"]();
    });
    it('should throw an error with uppercase letters in outport', function() {
      var shorthand;
      shorthand = function() {
        var c;
        return c = new component.Component({
          outPorts: {
            BarPort: {}
          }
        });
      };
      return chai.expect(shorthand).to["throw"]();
    });
    return it('should throw an error with special characters in inport', function() {
      var shorthand;
      shorthand = function() {
        var c;
        return c = new component.Component({
          inPorts: {
            '$%^&*a': {}
          }
        });
      };
      return chai.expect(shorthand).to["throw"]();
    });
  });
  describe('starting a component', function() {
    return it('should flag the component as started', function() {
      var c, i;
      c = new component.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        }
      });
      i = new socket.InternalSocket;
      c.inPorts["in"].attach(i);
      c.start();
      chai.expect(c.started).to.equal(true);
      return chai.expect(c.isStarted()).to.equal(true);
    });
  });
  return describe('shutting down a component', function() {
    return it('should flag the component as not started', function() {
      var c, i;
      c = new component.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        }
      });
      i = new socket.InternalSocket;
      c.inPorts["in"].attach(i);
      c.start();
      c.shutdown();
      chai.expect(c.started).to.equal(false);
      return chai.expect(c.isStarted()).to.equal(false);
    });
  });
});
