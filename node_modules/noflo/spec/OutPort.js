var chai, outport, socket;

if (!chai) {
  chai = require('chai');
}

if (typeof process !== 'undefined' && process.execPath && process.execPath.match(/node|iojs/)) {
  outport = require('../src/lib/OutPort');
  socket = require('../src/lib/InternalSocket');
} else {
  outport = require('noflo/src/lib/OutPort.js');
  socket = require('noflo/src/lib/InternalSocket.js');
}

describe('Outport Port', function() {
  describe('with addressable ports', function() {
    var s1, s2, s3;
    s1 = s2 = s3 = null;
    beforeEach(function() {
      s1 = new socket.InternalSocket;
      s2 = new socket.InternalSocket;
      return s3 = new socket.InternalSocket;
    });
    it('should be able to send to a specific port', function() {
      var p;
      p = new outport({
        addressable: true
      });
      p.attach(s1);
      p.attach(s2);
      p.attach(s3);
      chai.expect(p.listAttached()).to.eql([0, 1, 2]);
      s1.on('data', function() {
        return chai.expect(true).to.equal(false);
      });
      s2.on('data', function(data) {
        return chai.expect(data).to.equal('some-data');
      });
      s3.on('data', function() {
        return chai.expect(true).to.equal(false);
      });
      return p.send('some-data', 1);
    });
    it('should throw an error when sent data without address', function() {
      return chai.expect(function() {
        return p.send('some-data');
      }).to["throw"];
    });
    it('should throw an error when a specific port is requested with non-addressable port', function() {
      var p;
      p = new outport;
      p.attach(s1);
      p.attach(s2);
      p.attach(s3);
      return chai.expect(function() {
        return p.send('some-data', 1);
      }).to["throw"];
    });
    return it('should give correct port index when detaching a connection', function(done) {
      var expected, expectedAttached, expectedSockets, p;
      p = new outport({
        addressable: true
      });
      p.attach(s1, 3);
      p.attach(s2, 1);
      p.attach(s3, 5);
      expectedSockets = [s2, s3];
      expected = [1, 5];
      expectedAttached = [[3, 5], [3]];
      p.on('detach', function(socket, index) {
        var att, atts, _i, _len;
        chai.expect(socket).to.equal(expectedSockets.shift());
        chai.expect(index).to.equal(expected.shift());
        chai.expect(p.isAttached(index)).to.equal(false);
        atts = expectedAttached.shift();
        chai.expect(p.listAttached()).to.eql(atts);
        for (_i = 0, _len = atts.length; _i < _len; _i++) {
          att = atts[_i];
          chai.expect(p.isAttached(att)).to.equal(true);
        }
        if (!expected.length) {
          return done();
        }
      });
      p.detach(s2);
      return p.detach(s3);
    });
  });
  return describe('with caching ports', function() {
    var s1, s2, s3;
    s1 = s2 = s3 = null;
    beforeEach(function() {
      s1 = new socket.InternalSocket;
      s2 = new socket.InternalSocket;
      return s3 = new socket.InternalSocket;
    });
    it('should repeat the previously sent value on attach event', function(done) {
      var p;
      p = new outport({
        caching: true
      });
      s1.once('data', function(data) {
        return chai.expect(data).to.equal('foo');
      });
      s2.once('data', function(data) {
        chai.expect(data).to.equal('foo');
        return s2.once('data', function(data) {
          chai.expect(data).to.equal('bar');
          return done();
        });
      });
      p.attach(s1);
      p.send('foo');
      p.disconnect();
      p.attach(s2);
      p.send('bar');
      return p.disconnect();
    });
    return it('should support addressable ports', function(done) {
      var p;
      p = new outport({
        addressable: true,
        caching: true
      });
      p.attach(s1);
      p.attach(s2);
      s1.on('data', function() {
        return chai.expect(true).to.equal(false);
      });
      s2.on('data', function(data) {
        return chai.expect(data).to.equal('some-data');
      });
      s3.on('data', function(data) {
        chai.expect(data).to.equal('some-data');
        return done();
      });
      p.send('some-data', 1);
      p.disconnect(1);
      p.detach(s2);
      return p.attach(s3, 1);
    });
  });
});
